import logging
import asyncio
import schedule
import time
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from telegram.constants import ParseMode

from config import BOT_TOKEN, ADMIN_USER_ID, SUBSCRIPTION_PLANS, LOG_LEVEL, LOG_FILE
from database import Database
from signal_generator import SignalGenerator

# Configure logging
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class BinaryOptionsBot:
    def __init__(self):
        self.db = Database()
        self.signal_generator = SignalGenerator()
        self.application = None
        
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        user = update.effective_user
        user_id = user.id
        
        # Add user to database
        self.db.add_user(
            user_id=user_id,
            username=user.username,
            first_name=user.first_name,
            last_name=user.last_name
        )
        
        welcome_message = f"""
üöÄ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Binary Options Signals Bot!

üëã –ü—Ä–∏–≤–µ—Ç, {user.first_name}!

üìä –Ø –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é —Ç–æ—á–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è –±–∏–Ω–∞—Ä–Ω—ã—Ö –æ–ø—Ü–∏–æ–Ω–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–≥–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞.

üéØ –ú–æ–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
‚Ä¢ –¢–æ—á–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã CALL/PUT
‚Ä¢ –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –ø–∞—Ä—ã
‚Ä¢ –†–∞–∑–ª–∏—á–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ—Ä–µ–π–º—ã
‚Ä¢ –í—ã—Å–æ–∫–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–æ–≤
‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞

üí° –î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã –≤—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É:
        """
        
        keyboard = [
            [InlineKeyboardButton("üìä –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã", callback_data="free_signals")],
            [InlineKeyboardButton("üíé Premium –ø–æ–¥–ø–∏—Å–∫–∞", callback_data="premium")],
            [InlineKeyboardButton("üëë VIP –ø–æ–¥–ø–∏—Å–∫–∞", callback_data="vip")],
            [InlineKeyboardButton("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="statistics")],
            [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="help")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            welcome_message,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_text = """
üìö <b>–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞</b>

üîπ <b>–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>
/start - –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É
/status - –°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏
/signals - –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–∏–≥–Ω–∞–ª—ã
/statistics - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞

üîπ <b>–¢–∏–ø—ã –ø–æ–¥–ø–∏—Å–æ–∫:</b>
‚Ä¢ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è</b> - 1 —Å–∏–≥–Ω–∞–ª –≤ –¥–µ–Ω—å
‚Ä¢ <b>Premium</b> - –î–æ 10 —Å–∏–≥–Ω–∞–ª–æ–≤ –≤ –¥–µ–Ω—å
‚Ä¢ <b>VIP</b> - –ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã + –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç

üîπ <b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∏–≥–Ω–∞–ª—ã:</b>
1. –ü–æ–ª—É—á–∏—Ç–µ —Å–∏–≥–Ω–∞–ª –æ—Ç –±–æ—Ç–∞
2. –û—Ç–∫—Ä–æ–π—Ç–µ –ø–æ–∑–∏—Ü–∏—é –Ω–∞ –≤–∞—à–µ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ
3. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —É–∫–∞–∑–∞–Ω–Ω—É—é —Å—É–º–º—É
4. –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è —ç–∫—Å–ø–∏—Ä–∞—Ü–∏–∏
5. –î–æ–∂–¥–∏—Ç–µ—Å—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b>
‚Ä¢ –¢–æ—Ä–≥–æ–≤–ª—è –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –æ–ø—Ü–∏–æ–Ω–∞–º–∏ —Å–≤—è–∑–∞–Ω–∞ —Å —Ä–∏—Å–∫–∞–º–∏
‚Ä¢ –ù–µ –∏–Ω–≤–µ—Å—Ç–∏—Ä—É–π—Ç–µ –±–æ–ª—å—à–µ, —á–µ–º –º–æ–∂–µ—Ç–µ –ø–æ–∑–≤–æ–ª–∏—Ç—å —Å–µ–±–µ –ø–æ—Ç–µ—Ä—è—Ç—å
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏–≥–Ω–∞–ª—ã –∫–∞–∫ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∞–Ω–∞–ª–∏–∑–∞

üìû <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞:</b>
–ü–æ –≤—Å–µ–º –≤–æ–ø—Ä–æ—Å–∞–º –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.
        """
        
        await update.message.reply_text(help_text, parse_mode=ParseMode.HTML)
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /status command"""
        user_id = update.effective_user.id
        user = self.db.get_user(user_id)
        
        if not user:
            await update.message.reply_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.")
            return
        
        subscription_status = "‚úÖ –ê–∫—Ç–∏–≤–Ω–∞" if self.db.is_user_subscribed(user_id) else "‚ùå –ù–µ–∞–∫—Ç–∏–≤–Ω–∞"
        subscription_type = user.get('subscription_type', 'free')
        expires_at = user.get('subscription_expires')
        
        status_text = f"""
üìä <b>–°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏</b>

üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.get('first_name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}
üìÖ –¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏: {subscription_type.upper()}
üîê –°—Ç–∞—Ç—É—Å: {subscription_status}
        """
        
        if expires_at:
            status_text += f"\n‚è∞ –ò—Å—Ç–µ–∫–∞–µ—Ç: {expires_at}"
        
        keyboard = [
            [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="renew_subscription")],
            [InlineKeyboardButton("üìà –ü–æ–ª—É—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã", callback_data="get_signals")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            status_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
    
    async def signals_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /signals command"""
        await self.send_latest_signals(update.effective_user.id, update.message.reply_text)
    
    async def statistics_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /statistics command"""
        stats = self.signal_generator.get_statistics()
        
        stats_text = f"""
üìà <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞</b>

üìä –í—Å–µ–≥–æ —Å–∏–≥–Ω–∞–ª–æ–≤: {stats['total_signals']}
‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö: {stats['successful_signals']}
üìà –ü—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—Ö–∞: {stats['success_rate']:.1f}%
üïê –ü–æ—Å–ª–µ–¥–Ω–∏–π —Å–∏–≥–Ω–∞–ª: {stats['last_generated'].strftime('%H:%M:%S')}

üéØ <b>–¢–µ–∫—É—â–∏–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã:</b>
        """
        
        active_signals = self.db.get_active_signals()
        if active_signals:
            for signal in active_signals[:5]:  # Show last 5 signals
                stats_text += f"""
üî∏ {signal['asset']} - {signal['signal_type']}
   ‚è±Ô∏è –≠–∫—Å–ø–∏—Ä–∞—Ü–∏—è: {signal['expiry_time']}
   üìä –¢–æ—á–Ω–æ—Å—Ç—å: {signal['accuracy']}%
   üïê –°–æ–∑–¥–∞–Ω: {signal['created_at']}
                """
        else:
            stats_text += "\nüì≠ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"
        
        await update.message.reply_text(stats_text, parse_mode=ParseMode.HTML)
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle button callbacks"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        
        if query.data == "free_signals":
            await self.handle_free_signals(query)
        elif query.data == "premium":
            await self.handle_premium_subscription(query)
        elif query.data == "vip":
            await self.handle_vip_subscription(query)
        elif query.data == "statistics":
            await self.handle_statistics(query)
        elif query.data == "help":
            await self.handle_help(query)
        elif query.data == "get_signals":
            await self.send_latest_signals(user_id, query.edit_message_text)
        elif query.data == "renew_subscription":
            await self.handle_renew_subscription(query)
    
    async def handle_free_signals(self, query):
        """Handle free signals request"""
        user_id = query.from_user.id
        
        # Check if user already got free signal today
        user = self.db.get_user(user_id)
        if user and user.get('last_activity'):
            last_activity = datetime.fromisoformat(user['last_activity'].replace('Z', '+00:00'))
            if datetime.now() - last_activity < timedelta(days=1):
                await query.edit_message_text(
                    "‚è∞ –í—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–∏–≥–Ω–∞–ª —Å–µ–≥–æ–¥–Ω—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≤—Ç—Ä–∞ –∏–ª–∏ –æ—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É!",
                    parse_mode=ParseMode.HTML
                )
                return
        
        # Generate and send free signal
        signals = self.signal_generator.generate_signals_for_all_assets()
        if signals:
            signal = signals[0]  # Take first signal
            await self.send_signal_message(query.edit_message_text, signal, user_id)
        else:
            await query.edit_message_text(
                "üòî –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Å–µ–π—á–∞—Å –Ω–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ!",
                parse_mode=ParseMode.HTML
            )
    
    async def handle_premium_subscription(self, query):
        """Handle premium subscription request"""
        subscription_text = f"""
üíé <b>Premium –ø–æ–¥–ø–∏—Å–∫–∞</b>

üìä <b>–ß—Ç–æ –≤–∫–ª—é—á–µ–Ω–æ:</b>
‚Ä¢ –î–æ 10 —Å–∏–≥–Ω–∞–ª–æ–≤ –≤ –¥–µ–Ω—å
‚Ä¢ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞
‚Ä¢ –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ 24/7

üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> ${SUBSCRIPTION_PLANS['premium'] * 2} –∑–∞ {SUBSCRIPTION_PLANS['premium']} –¥–Ω–µ–π

üí≥ <b>–°–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã:</b>
‚Ä¢ –ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞
‚Ä¢ –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞
‚Ä¢ –≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–µ –∫–æ—à–µ–ª—å–∫–∏

–î–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.
        """
        
        keyboard = [
            [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", callback_data="pay_premium")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_main")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            subscription_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
    
    async def handle_vip_subscription(self, query):
        """Handle VIP subscription request"""
        subscription_text = f"""
üëë <b>VIP –ø–æ–¥–ø–∏—Å–∫–∞</b>

üìä <b>–ß—Ç–æ –≤–∫–ª—é—á–µ–Ω–æ:</b>
‚Ä¢ –ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã
‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
‚Ä¢ –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä
‚Ä¢ –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
‚Ä¢ –ê–Ω–∞–ª–∏–∑ –≤–∞—à–µ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è

üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> ${SUBSCRIPTION_PLANS['vip'] * 3} –∑–∞ {SUBSCRIPTION_PLANS['vip']} –¥–Ω–µ–π

üí≥ <b>–°–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã:</b>
‚Ä¢ –ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞
‚Ä¢ –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞
‚Ä¢ –≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–µ –∫–æ—à–µ–ª—å–∫–∏

–î–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.
        """
        
        keyboard = [
            [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", callback_data="pay_vip")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_main")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            subscription_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
    
    async def handle_statistics(self, query):
        """Handle statistics request"""
        stats = self.signal_generator.get_statistics()
        
        stats_text = f"""
üìà <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞</b>

üìä –í—Å–µ–≥–æ —Å–∏–≥–Ω–∞–ª–æ–≤: {stats['total_signals']}
‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö: {stats['successful_signals']}
üìà –ü—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—Ö–∞: {stats['success_rate']:.1f}%
üïê –ü–æ—Å–ª–µ–¥–Ω–∏–π —Å–∏–≥–Ω–∞–ª: {stats['last_generated'].strftime('%H:%M:%S')}
        """
        
        keyboard = [
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_main")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            stats_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
    
    async def handle_help(self, query):
        """Handle help request"""
        help_text = """
üìö <b>–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞</b>

üîπ <b>–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>
/start - –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É
/status - –°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏
/signals - –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–∏–≥–Ω–∞–ª—ã
/statistics - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞

üîπ <b>–¢–∏–ø—ã –ø–æ–¥–ø–∏—Å–æ–∫:</b>
‚Ä¢ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è</b> - 1 —Å–∏–≥–Ω–∞–ª –≤ –¥–µ–Ω—å
‚Ä¢ <b>Premium</b> - –î–æ 10 —Å–∏–≥–Ω–∞–ª–æ–≤ –≤ –¥–µ–Ω—å
‚Ä¢ <b>VIP</b> - –ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã + –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç

‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b>
‚Ä¢ –¢–æ—Ä–≥–æ–≤–ª—è –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –æ–ø—Ü–∏–æ–Ω–∞–º–∏ —Å–≤—è–∑–∞–Ω–∞ —Å —Ä–∏—Å–∫–∞–º–∏
‚Ä¢ –ù–µ –∏–Ω–≤–µ—Å—Ç–∏—Ä—É–π—Ç–µ –±–æ–ª—å—à–µ, —á–µ–º –º–æ–∂–µ—Ç–µ –ø–æ–∑–≤–æ–ª–∏—Ç—å —Å–µ–±–µ –ø–æ—Ç–µ—Ä—è—Ç—å
        """
        
        keyboard = [
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_main")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            help_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
    
    async def handle_renew_subscription(self, query):
        """Handle subscription renewal request"""
        keyboard = [
            [InlineKeyboardButton("üíé Premium", callback_data="pay_premium")],
            [InlineKeyboardButton("üëë VIP", callback_data="pay_vip")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_main")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "üí≥ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è –ø—Ä–æ–¥–ª–µ–Ω–∏—è:",
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
    
    async def send_signal_message(self, send_function, signal: dict, user_id: int):
        """Send formatted signal message"""
        signal_text = f"""
üö® <b>–ù–û–í–´–ô –°–ò–ì–ù–ê–õ</b>

üìä <b>–ê–∫—Ç–∏–≤:</b> {signal['asset']}
üéØ <b>–¢–∏–ø:</b> {signal['signal_type']}
‚è±Ô∏è <b>–≠–∫—Å–ø–∏—Ä–∞—Ü–∏—è:</b> {signal['expiry_time']}
üí∞ <b>–í—Ö–æ–¥:</b> {signal['entry_price']}
üéØ <b>–¶–µ–ª—å:</b> {signal['target_price']}
üõë <b>–°—Ç–æ–ø-–ª–æ—Å—Å:</b> {signal['stop_loss']}
üìà <b>–¢–æ—á–Ω–æ—Å—Ç—å:</b> {signal['accuracy']}%

‚è∞ <b>–í—Ä–µ–º—è:</b> {signal['timestamp'].strftime('%H:%M:%S')}

üí° <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:</b>
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 1-2% –æ—Ç –¥–µ–ø–æ–∑–∏—Ç–∞
‚Ä¢ –°–ª–µ–¥—É–π—Ç–µ —É–∫–∞–∑–∞–Ω–Ω—ã–º —É—Ä–æ–≤–Ω—è–º
‚Ä¢ –ù–µ —Ç–æ—Ä–≥—É–π—Ç–µ –Ω–∞ —ç–º–æ—Ü–∏—è—Ö

‚ö†Ô∏è <b>–†–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç:</b>
–¢–æ—Ä–≥–æ–≤–ª—è –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –æ–ø—Ü–∏–æ–Ω–∞–º–∏ —Å–≤—è–∑–∞–Ω–∞ —Å –≤—ã—Å–æ–∫–∏–º–∏ —Ä–∏—Å–∫–∞–º–∏.
        """
        
        keyboard = [
            [InlineKeyboardButton("üìä –ü–æ–ª—É—á–∏—Ç—å –µ—â–µ —Å–∏–≥–Ω–∞–ª—ã", callback_data="get_signals")],
            [InlineKeyboardButton("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="statistics")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await send_function(
            signal_text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
        
        # Save signal to database
        signal_id = self.db.add_signal(
            asset=signal['asset'],
            signal_type=signal['signal_type'],
            expiry_time=signal['expiry_time'],
            entry_price=signal['entry_price'],
            target_price=signal['target_price'],
            stop_loss=signal['stop_loss'],
            accuracy=signal['accuracy']
        )
        
        logger.info(f"Signal sent to user {user_id}: {signal}")
    
    async def send_latest_signals(self, user_id: int, send_function):
        """Send latest signals to user"""
        # Check subscription
        if not self.db.is_user_subscribed(user_id):
            await send_function(
                "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏. –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤!",
                parse_mode=ParseMode.HTML
            )
            return
        
        # Get active signals
        active_signals = self.db.get_active_signals()
        
        if not active_signals:
            # Generate new signals
            signals = self.signal_generator.generate_signals_for_all_assets()
            if signals:
                for signal in signals[:3]:  # Send up to 3 signals
                    await self.send_signal_message(send_function, signal, user_id)
            else:
                await send_function(
                    "üòî –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Å–µ–π—á–∞—Å –Ω–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ!",
                    parse_mode=ParseMode.HTML
                )
        else:
            # Send existing active signals
            for signal in active_signals[:3]:
                await self.send_signal_message(send_function, signal, user_id)
    
    async def broadcast_signals(self):
        """Broadcast signals to all subscribed users"""
        try:
            # Generate new signals
            signals = self.signal_generator.generate_signals_for_all_assets()
            
            if not signals:
                logger.info("No signals generated for broadcast")
                return
            
            # Get all subscribed users
            subscribed_users = self.db.get_subscribed_users()
            
            if not subscribed_users:
                logger.info("No subscribed users found")
                return
            
            # Send signals to all subscribed users
            for user_id in subscribed_users:
                try:
                    for signal in signals[:2]:  # Send up to 2 signals per broadcast
                        await self.send_signal_message(
                            lambda text, **kwargs: self.application.bot.send_message(user_id, text, **kwargs),
                            signal,
                            user_id
                        )
                        await asyncio.sleep(0.1)  # Small delay to avoid rate limiting
                except Exception as e:
                    logger.error(f"Error sending signal to user {user_id}: {e}")
                    continue
            
            logger.info(f"Broadcasted {len(signals)} signals to {len(subscribed_users)} users")
            
        except Exception as e:
            logger.error(f"Error in broadcast_signals: {e}")
    
    async def admin_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle admin commands"""
        user_id = update.effective_user.id
        
        if user_id != ADMIN_USER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
            return
        
        if not context.args:
            await update.message.reply_text(
                "üîß <b>–ö–æ–º–∞–Ω–¥—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:</b>\n\n"
                "/admin broadcast - –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º\n"
                "/admin stats - –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\n"
                "/admin users - –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
                "/admin signal - –°–æ–∑–¥–∞—Ç—å —Å–∏–≥–Ω–∞–ª –≤—Ä—É—á–Ω—É—é",
                parse_mode=ParseMode.HTML
            )
            return
        
        command = context.args[0]
        
        if command == "broadcast":
            await self.broadcast_signals()
            await update.message.reply_text("‚úÖ –°–∏–≥–Ω–∞–ª—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º!")
        
        elif command == "stats":
            stats = self.signal_generator.get_statistics()
            users = self.db.get_all_users()
            subscribed_users = self.db.get_subscribed_users()
            
            stats_text = f"""
üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞</b>

üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(users)}
‚úÖ –ü–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {len(subscribed_users)}
üìà –°–∏–≥–Ω–∞–ª–æ–≤ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {stats['total_signals']}
üéØ –ü—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—Ö–∞: {stats['success_rate']:.1f}%
            """
            
            await update.message.reply_text(stats_text, parse_mode=ParseMode.HTML)
        
        elif command == "users":
            users = self.db.get_all_users()
            users_text = f"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(users)}\n\n"
            
            for i, user_id in enumerate(users[:10], 1):  # Show first 10 users
                user = self.db.get_user(user_id)
                if user:
                    users_text += f"{i}. {user.get('first_name', 'Unknown')} (@{user.get('username', 'no_username')})\n"
            
            if len(users) > 10:
                users_text += f"\n... –∏ –µ—â–µ {len(users) - 10} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"
            
            await update.message.reply_text(users_text)
        
        elif command == "signal":
            if len(context.args) < 4:
                await update.message.reply_text(
                    "‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /admin signal <asset> <type> <expiry> [accuracy]"
                )
                return
            
            asset = context.args[1]
            signal_type = context.args[2]
            expiry_time = context.args[3]
            accuracy = float(context.args[4]) if len(context.args) > 4 else 85.0
            
            signal = {
                'asset': asset,
                'signal_type': signal_type,
                'expiry_time': expiry_time,
                'entry_price': 1.0000,
                'target_price': 1.0010,
                'stop_loss': 0.9990,
                'accuracy': accuracy,
                'timestamp': datetime.now()
            }
            
            await self.broadcast_signals()
            await update.message.reply_text(f"‚úÖ –°–∏–≥–Ω–∞–ª —Å–æ–∑–¥–∞–Ω –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: {asset} {signal_type}")
    
    def setup_handlers(self):
        """Setup bot handlers"""
        self.application.add_handler(CommandHandler("start", self.start))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        self.application.add_handler(CommandHandler("signals", self.signals_command))
        self.application.add_handler(CommandHandler("statistics", self.statistics_command))
        self.application.add_handler(CommandHandler("admin", self.admin_command))
        self.application.add_handler(CallbackQueryHandler(self.button_callback))
    
    def setup_scheduler(self):
        """Setup signal generation scheduler"""
        # Generate signals every 30 minutes
        schedule.every(30).minutes.do(self.run_signal_generation)
        
        # Broadcast signals every hour
        schedule.every().hour.do(self.run_broadcast)
    
    def run_signal_generation(self):
        """Run signal generation in background"""
        asyncio.create_task(self.broadcast_signals())
    
    def run_broadcast(self):
        """Run broadcast in background"""
        asyncio.create_task(self.broadcast_signals())
    
    async def run(self):
        """Run the bot"""
        if not BOT_TOKEN:
            logger.error("BOT_TOKEN not found in environment variables")
            return
        
        self.application = Application.builder().token(BOT_TOKEN).build()
        self.setup_handlers()
        self.setup_scheduler()
        
        logger.info("Starting Binary Options Signals Bot...")
        
        # Start the bot
        await self.application.initialize()
        await self.application.start()
        await self.application.updater.start_polling()
        
        try:
            # Keep the bot running
            while True:
                schedule.run_pending()
                await asyncio.sleep(1)
        except KeyboardInterrupt:
            logger.info("Stopping bot...")
        finally:
            await self.application.updater.stop()
            await self.application.stop()
            await self.application.shutdown()

async def main():
    """Main function"""
    bot = BinaryOptionsBot()
    await bot.run()

if __name__ == "__main__":
    asyncio.run(main()) 